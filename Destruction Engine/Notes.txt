ECS System: Basic component and entity template setup.
			Basic component manager
			Basic component storage.
			Basic entity manager
			Basic general system
			Basic Coordinator class that handles all the managers in one spot
			Basic Event Bus 
			Re-Written Texture class as a c struct
			Basic main class based off of Texture clicker.cpp to actually have a proper insertion point

			Have to actually figure out how to properly initialise values into the grid. Then test 
			that grid debug system is working and make a debug system for pathfinding
			The pathfinding system requests grid from the Grid system using an event and then runs a* on it.
			Need to figure out memory management and garbage collection. (stretch goal)


Look into scene graphs for how to make child-parent relationships in scene: https://en.wikipedia.org/wiki/Scene_graph
Code for engine based off of https://savas.ca/nomad and https://austinmorlan.com/posts/entity_component_system/

Performance Optimisation: Use Entity archetypes -> organise entites by the components that they have as children 
							and then just have the systems fetch entities from these archetypes.
Look into Isobands for Marching squares ranges: https://en.wikipedia.org/wiki/Marching_squares#Isobands

Week 1 Notes:
Implemented an Event Bus
Successful conversion of old erasing system to use the new ECS engine.
Converted texture class into struct format, so that could pass around pure data rather than objects (even though
there is no meaningful difference between structs and classes in c++)
Created three basic components (Transform, Collider and Sprite-> this is just a re-write of the old Texture class)
Modified the old erasure/destruction methods to work with the new Sprite struct.
Re-wrote the insertion point (it is now in an actual file called Main.cpp rather than just Texture Clicker).
It now uses the ECS structures -> this allows me to package away the code into different systems.
4 new systems that accomplish this:
			RenderSystem -> Handles sprite rendering
			TransformSystem -> Handles movement (not really used at the moment, needs more work)
			DestructionSystem -> Handles sprite destruction
			DebugSystem -> Displays debug information, currently only used for seeing collider outlines but can easily be extended in future.
No physics system since I am not sure yet how I am going to link it with the sprite destruction. That will be a future 
part of the project
I created an input manager class, mostly to help tell the rest of the program what keys are pressed (right now I 
only use it for mouse buttons). SDL does have its own in built input system, and this is essentially just a messenger
class that carries the information from SDL to the rest of the system, since the SDL manager works by polling 
an event queue (done in main), which the manager then uses to update its own variables that can be seen by all systems
(since it is stored in the Coordinator class).

Note to future self: Currently I am just passing the raw structs around when dealing with data in the ECS system.
This is not such a big deal for entities, but some of the components (especially Sprite), have the potential to 
become quite large. It might be better to deal with pointers to improve performance. Look into this in future.
