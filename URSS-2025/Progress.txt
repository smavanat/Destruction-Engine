Overview of whole project progress:
ECS System: Basic component and entity template setup.
			Basic component manager
			Basic component storage.
			Basic entity manager
			Basic general system
			Basic Coordinator class that handles all the managers in one spot
			Basic Event Bus 
			
			Re-Written Texture class as a c struct
			Basic main class based off of Texture clicker.cpp to actually have a proper insertion point
			Basic Grid, pathfinding and tile systems
			Debug manager and several debug systems to help with debugging and visualisations
			GridManager to couple Grid and Pathfinding together.
			Basic Desutructible Pathfinding
			A good TileSet struct
			Support for Box, Circle, Capsule and Polygon colliders
			Assigment of colliders to tiles at init and updating of subcell grid at runtime (needs optimisation)
			Agents that can use the basic pathfinding system
			Add agents that can use the destruction system to find faster paths 

Week 1 Notes:
Implemented an Event Bus
Successful conversion of old erasing system to use the new ECS engine.
Converted texture class into struct format, so that could pass around pure data rather than objects (even though
there is no meaningful difference between structs and classes in c++)
Created three basic components (Transform, Collider and Sprite-> this is just a re-write of the old Texture class)
Modified the old erasure/destruction methods to work with the new Sprite struct.
Re-wrote the insertion point (it is now in an actual file called Main.cpp rather than just Texture Clicker).
It now uses the ECS structures -> this allows me to package away the code into different systems.
4 new systems that accomplish this:
			RenderSystem -> Handles sprite rendering
			TransformSystem -> Handles movement (not really used at the moment, needs more work)
			DestructionSystem -> Handles sprite destruction
			DebugSystem -> Displays debug information, currently only used for seeing collider outlines but can easily be extended in future.
No physics system since I am not sure yet how I am going to link it with the sprite destruction. That will be a future 
part of the project
I created an input manager class, mostly to help tell the rest of the program what keys are pressed (right now I 
only use it for mouse buttons). SDL does have its own in built input system, and this is essentially just a messenger
class that carries the information from SDL to the rest of the system, since the SDL manager works by polling 
an event queue (done in main), which the manager then uses to update its own variables that can be seen by all systems
(since it is stored in the Coordinator class).

Week 2:
Implemented a tilemap system. It loads grid data from a .map file, and then uses this, alongside a provided stylesheet,
to render the grid on the screen.
Implemented a Grid system. The difference between this and the tilemap, is that the tile map is used just for 
initial rendering. The grid system checks and updates the pathfinding system on which tiles are walkable or not
Implemented a pathfinding system. Currently it only does very simple 8-directional a*. Need to add path simplification
and steering behaviours in future, but this it is not necessary right now.
The pathfinding system requests grid from the Grid system using an event and then runs a* on it.
These three system currently work well and are linked, but this relies on using a lot of global variables and constants
It would be good to find a way to package these systems more securely in one to enable multiple grids etc.

Overhauled the way that debugging works, there is now a DebugManager class that batch calls the debuggers
All debuggers now inherit from a type synonym of System called Debug. It would be good to make this an actual class,
since all Debug - based systems all have the exact same structure, the init() and update() methods from the System class,
plus an onSomeDebugEvent() method, and a boolean display. However, I am not sure how to implement the 
onSomeDebugEvent() method as a virtual inheritable method, while constraining the type in the definition, to only
match the event that the specific Debug class uses to avoid erroneous Event calls.

Added a GridDebugSystem and a PathFindingDebugSystem, which are used to provide helpful viewing for the Grid and
Pathfinding systems respectively

Fixed a large bug in the Coordinator that meant Systems could be created without a signature. This led to some 
very annoying errors where entities where being added to systems where they should not be because the system 
has a blank signature at the point of the entities' instantiation, and this then crashed the program as the system 
attempted to access a component the entity did not have.

Week 3:
Made an attempt at implementing a destruction pathfinding system using marching squares. Quickly realised that it 
would not work, since essentially it would require breaking down the entire grid into subcells, finding a path through
them, and building it back up into full cells to account for agents of different sizes, which would have been 
cumbersome to code and in terms of performance.

Settled on trying a different approach by changing the way tile data was stored. Created a GridManager class, 
which stored a shared_ptr to a GridSystem, a PathFindingSystem and GridData (a new struct I had created to store
data about grid dimensions as well as the tile layout), that is passed to the GridSystem and PathFindingSystem so
that grid updates don't have to be sent as events, can just check the data at a pointer.

Created a TileData struct to hold specific data about tiles. Tiles now have a status, which can be 0 (passable)
1 (impassable) or 2 (partial). They also store a representation of their layout as subcells. Right now I am using
4x4 subcell grids, but I think that this should be expanded in future to allow dynamic sizing based on the dimensions
of the tiles themselves, i.e. bigger tiles have larger subcell grids. Currently this is an array of uint8, but it 
could be changed to a bitset for optimisation purposes. It also stores which sides of the tile have passable subcells. 
This is (sortof?) useful because it can make some checks quicker. The GridData struct stores a vector of these 
TileData structs to represent the layout of the grid.

Started the process of decoupling the TileSystem from the GridSystem. This is because I feel that there could be 
multiple tilesets layered on top of eachother (background, terrain, objects, etc.) which will make determining 
the pathfinding grid much harder, and also because the pathfinding grid may encompass many different tilesets, 
which represent different regions of the map. Right now, these systems are still loaded from the same file for 
convenience, but I hope to change this to be more rigorous in future. I think that determining which tiles 
are passable or impassable could still be done via files, but partial tiles need to be done via checking colliders
or something.

Started implementing the pathfinding system on the subcell grids. Essentially, it starts by running some checks 
to see if (a), there are more than two sides with passable subcell tiles, and (b), that the agent can actually enter
onto the tile. Then it goes over the subcell grid, and marks all the cells that the agent could stand in (assuming
that cell was the top left corner), and then runs bfs. If the bfs reaches a tile that is on a different edge to the 
one the agent started from, we have a path for this agent through the subcell grid. An important note is that when
we add neighbour cells to the bfs queue, we only add neighbours on the non-diagonal directions. This is because 
agents will most likely have to use steering behaviours to path through partial tiles, and since both the agents 
and whatever is in the partial tile will have colliders, moving across diagonals probably means that the agent 
will just end up ramming themselves into a corner, unable to pass through

There are some assumptions for this algorithm: The size of the agent is less than 4, and the shape of the agent 
could be approximated to a square. The reason for the first assumption is because I haven't figured out pathing across
multiple subcell grids (that is the next step), and for the second is because then we would need to account for
agent orienation, which adds a lot of new complexities which I could really do without at this point, but it is 
something that I plan to revisit once I have a full working version of this pathfinding system.

Currently, this is only being used to determine pathable neighbours in my modified A*. There is currently no 
version of this algorithm that actually figures out where to go if a partial tile is the current tile. That needs
to be added.

Week 4 (and a little bit of 5):
Finished the destructible pathfinding system.
My first attempt at the algorithm was as follows:
	Do normal A*, with the following cases
	(1)If the current tile is walkable, and the neighbour tile is walkable, do A* as normal
	(2)If the current tile is walkable, and the neighbour tile is partial, check if the neighbour
	tile is pathable by itself, then with an adjacent tile. If it is, push it to the open list.
	(3)If the current tile is partial, for each of its neighbours, check if there is a path from 
	the current tile to the adjacent tile without crossing another tile.
I quickly realised that I could replace step 2 with just checking if there is a path from the current
tile to the partial tile as in step 3. This reduced the size of my code by about 1/3
The checking for a path works the same as defined in my notes for week 3, except now the algorithm 
is modified to find a proper ending position that the tile can reach. This is done by checking all of 
the subcells adjacent to the current tile. If there is a subcell on the target neighboour tile that is 
considered walkable (just being able to fit partially on it, not the whole agent), then that is a 
satisfactory goal position and we run bfs to get a path from the start position to the end position.

There is currently a clear optimisation in that the algorithm keeps recalculating the pathable subcells
for each neighbour, even though these would be the same for each, only the goal position changes.

Currently the assumptions for the algorithm remain the same. I do plan on addressing these and the optimisation
in future, I just want to work on other parts of the program and first to have a somewhat working
prototype.

Week 5 (Rest of):
I have successfully created a CMakeLists.txt file, so the project can now be built on x64 Windows using either 
Visual Studio or MinGW. The reason for this platform specificity is because of SDL3, which requires different library 
files for each different platform and system architecture, and setting up this minimal functionality took me two days 
(I had hoped for half an hour). 

I have started working on adding functionality to update the pathfinding grid at runtime to reflect the destruction of tiles. 
I have begun modifying my minimal TileSystem class to reflect this, and I have successfully completed this task somewhat, however,
the tile system works the same as before now. But everything else is so broken, including: grid rendering (the positioning is off), 
and for some reason the grid destruction doesn't work even though the new tile entities should have colliders. Another interesting note, 
every time we split a texture, our memory use doubles. But overall cpu use has halved (15% - 7%) (yay)

Week 6:
Fixed all of the bugs from the tilesystem and split the sprite class in two, Sprite and TileSprite.
TileSprite is for the tiles that only use a part of a texture to render, Sprite is for everything else (the destructible stuff)
This is so we can reduce the size of the Sprite struct to reduce cache misses and avoid unnecessary conflation of responsiblities
in terms of rendering.

Fixed the performance problem by turning on vsync and buy using SDL_Delay (we're down to 0.6% usage, very respectable). However, I have
turned off SDL_Delay for now, since it also makes the by-hand texture erasure very laggy. Will have to work on this in future.

Attempted an implemetation of Griener-Hormann for polygon clipping, but it could not handle the degenerate case of edge overlap which 
is definitely going to occur in this program. Frustrated, and wanting to save time, I downloaded an implementation of the Martinez-
Rueda-Feito algorithim (the actual source code they used in their paper, found here: https://www4.ujaen.es/~fmartin/bool_op.html), but 
I think it is really poorly written and bloated. I think it works in my program for now, but I am definitely going to re-write it in my
own style and remove a lot of the bloat.

I have almost finished implementing my algorithm for assigning colliders to specific grid cells. Currently it is very inefficient, as I 
need to implement a quadtree for proper spatial partitioning. The current algorithm is as follows:
Store all colliders that are for entites that are considered "terrain" (i.e. tiles) in their own array. Loop over this array, and also
the entirety of the entities in the gridsystem. Find if an entity in the grid system or a collider overlap using the seperating axis theorem
If they do overlap, then find which of the subcells of that tile overlap using SAT. 
Run MRF tileclipping on all the overlapping subcells to get the intersection point. If this intersection area (calculated using the 
shoelace formula) amounts to more than 20% (an arbitrary number) of the subcell's area, consider it filled. 
Should add code to make all other subcells unfilled
Currently there is a bug where sometimes the collider pointers in the array of terrain colliders come up null. Need to figure out 
why and fix it. It may be something to do with the memory leak errors I am getting in gdb from the loadTileSet function.

Week 7:
I have fixed the null pointer bug. It was because I forgot to account for the size of pointers when mallocing, leading to out of 
bounds errors. This means I have finished a very simple and stupid implementation of tilemap initialsation and init and runtime updating,
but I have figured out a way to significantly optimise it and will go about implementing the fixes in future.

I have added support for Box, Circle, Capsule and Polygon colliders, meaning it is much easier now to setup tiles and simple agents
This was done by adding an enum containing all of the collider types, and just switching on them whenever needed (e.g. for visualisation)

Got rid of the GridSystem class since there was no need for it as the GridData struct basically did everything it did and more. This 
probably means we can also get rid of GridSystemManager since at this point it is literally just a wrapper for the Pathfinding System.

Fixed a bug where mrf was failing because the order of points representing a polygon collider outline where out of order. Had to 
wirte a whole system for re-ordering them. I extracted the unique edges and then formed a chain of points that circumnavigated the whole
polygon boundary.

Finished the updating of the tile grid at runtime:
Essentially, after a tile is destroyed, we get its collider and then we set all subcells that it overlaps to be walkable.
Then we get the colliders of the new tiles sprites formed, and check for overlap with subcells, and if a subcell has more than 40% 
(can be adjusted) of its area covered by a collider, it is considered unwalkable. Use martinez-finto-rueda tile clipping and the shoelace
formula to determine the overlapping area.
Then re-evaluate the tile's current status (walkable, unwalkable or partial) and the exitable status of its four sides.

Fixed a bug where erasing would only work if the point where the user clicked was within an erasable object, and did not account for 
the radius of erasure being able to overlap with the given erasable sprite.

I added a simple agent that can follow the pre-defined pathfind path. The next step will be to upgrade it so it can modify the 
terrain to get a faster path.

Fixed a bug where colliders where being used after they had been removed from the world.

Week 8:
Implemented a way for the agents to find a destructible path through the environment:
Now when iterating over neighbour tiles, we instead treat non-passable partial tiles and impassable tiles as "bad" neighbours, as opposed to 
the "good" passable tiles and partial tiles. All tiles are technically now passable, but "bad" tiles have a movement penalty (it costs twice to
move through them as it would through a normal tile).
In order to figure out what direction the destruction occured on a "bad" tile to make it passable, we simply just consider the direction the agent 
came from. We can't really update the tilemap in real time as that would break once the current path was made invalid for some reason (e.g. a new endpoint).

The way the destruction is implemented visually is very simplistic:
Once the agent reaches an impassible tile it simply destroys the tile in front of it in a pre-defined rectangular area that was created to approximately cover
an entire tile and be the width of the agent. This then allows the agent to pass through unobstructed, and any slight changes due to collision are admirably handled
by box2D.

I would consider the project finished at this point, in terms of basic functionality. I think I am slightly running out of time, so I will unfortunately have to 
put off most optimisations, and instead focus on making a final demo that can be used to show the capabilities of this system.

Week 9:
Finished implementing the demo. There are three various scenarios that can be viewed:
The first is a grid that is almost entirely covered with impassable tiles except for the start and end tiles. The user can then erase a route through
the tiles that will then then be highlighted by a debug path diagram.
The second scenario is much like the first, except there is also an agent that follows the outlined path to reach the end.
The third scenario features no user interaction, since it is a demo of the agent's destruction ability to reach the end tile from the start tile.
